# Introduction

When a service needs data owned by another service, there are two main strategies to obtain the sought data:

1) A service can ask the data to the service that owns it, and wait until the data is sent back to it. This is a synchronous communication pattern.

2) The system can be architected so that data owned by a service, but needed by other services, is published to an infrastructural component that stores the data for some pre-defined amount of time. This additional component allows publishing and consuming to happen at different times, effectively decoupling services, and hence enabling services to communicate asynchronously.

Synchronous communication, in the context of microservices, is an architectural pattern smell. That's because it tangles your services together and reduces their resiliency. What happens when a service makes a synchronous call to another service? The caller service needs to wait for an answer. Try to imagine what happens if the contacted service is slow at responding, or maybe won't respond at all because it crashed. The consequence for your system is catastrophic, as a failure of the called service propagates to the caller service. In a nutshell, failure is not contained. If you think about it, when your services communicate synchronously, you are effectively building a distributed monolith. Services are strongly coupled. If one service isn't available, other services may also appear to be unavailable. Many of the benefits of a microservice architecture are lost, and you are left only with a system that will inevitably have outages, making your users unhappy, and hence putting your business at risk.

The solution is to avoid synchronous communication and instead architect your system to use communicate asynchronously. As hinted before, one can use an infrastructural component to enable services to communicate asynchronously. This component is commonly referred to as a [message broker](https://en.wikipedia.org/wiki/Message_broker). Various technologies that can be used as a message broker exist, such as [Google Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/overview), [Kafka](http://kafka.apache.org/), and [RabbitMQ](https://www.rabbitmq.com/).

Lagom allows services to easily communicate both synchronously and asynchronously. Both communication strategies have their use, but you should make an effort to architect your system of microservices using asynchronous communication whenever possible. To help you with this, Lagom provides a [[Message Broker API|MessageBroker]] that abstracts over specific message broker technologies, and makes  it dead simple for services to share data. Currently, Lagom only supports an implementation of the Message Broker API that uses Kafka, but other implementations may become available in the future.
